以前常觉得DOS的命令行功能太弱，无法象UNIX一样可以用命令行完成非常复杂的操作。实际上，当MS从WIN2K开始将命令行增强后，已经借鉴了相当多UNIX的优点，虽然还无法做到象UNIX那么灵活，但已可完成绝大多数的任务，比如用&&和||连接两个（或更多）命令，由前一个的返回值来决定下一个是否执行，等等。而在这些增强中，最明显的，就是FOR命令。 

  举个例子，用适当的参数，可用FOR命令将 date /t 的输出 从 `Sat 07/13/2002` 变成你想要的格式，比如， `2002-07-13`： 

 
  程序代码: 
c:＞for /f `tokens=2,3,4 delims=/ ` %a in (`date /t`) do @echo %c-%a-%b 
2002-07-13 

 
 
 
  该例将在（3）中详细说明。 

  0. 基本应用 

  简单说，FOR是个循环，可以用你指定的循环范围生成一系列命令。最简单的例子，就是人工指定循环范围，然后对每个值执行指定的命令。例如，想快速报告每个硬盘分区的剩余空间： 

 
  程序代码: 
for %a in (c: d: e: f do @dir %a | find `bytes free` 

 
 
  将输出： 

 
  程序代码: 
8 Dir(s) 1,361,334,272 bytes free 
15 Dir(s) 8,505,581,568 bytes free 
12 Dir(s) 12,975,149,056 bytes free 
7 Dir(s) 11,658,854,400 bytes free 

 
 
  用它可以使一些不支持通配符的命令对一系列文件进行操作。在WIN9X中，TYPE命令（显示文件内容）是不支持*.txt这种格式的（WIN2K开始TYPE已支持通配）。遇到类似情况就可以用FOR： 

 
  程序代码: 
for %a in (*.txt) do type %a 

 
 
 
  这些还不是FOR最强大的功能。我认为它最强大的功能，表现在以下这些高级应用： 

 
  1. 可以用 /r 参数遍历整个目录树 

  2. 可以用 /f 参数将文本文件内容作为循环范围 

  3. 可以用 /f 参数将某一命令执行结果作为循环范围 

  4. 可以用 %~ 操作符将文件名分离成文件名、扩展名、盘符等独立部分 

 
  现分别举例说明如下： 

  1. 用 /r 遍历目录树 

  当用 *.* 或 *.txt 等文件名通配符作为 for /r 的循环范围时，可以对当前目录下所有文件（包括子目录里面的文件）进行操作。举个例子，你想在当前目录的所有txt文件（包括子目录）内容中查找`bluebear`字样，但由于find本身不能遍历子目录，所以我们用for: 

 
  程序代码: 
for /r . %a in (*.txt) do @find `bluebear` %a 

 
 
 
  find 前面的 @ 只是让输出结果不包括 find 命令本身。这是DOS很早就有的功能。和FOR无关。 

  当用 . 作为循环范围时，for 只将子目录的结构（目录名）作为循环范围，而不包括里面的文件。有点象 TREE 命令，不过侧重点不同。TREE 的重点是用很漂亮易读的格式输出，而FOR的输出适合一些自动任务，例如，我们都知道用CVS管理的项目中，每个子目录下都会有一个CVS目录，有时在软件发行时我们想把这些CVS目录全部去掉： 

 
  程序代码: 
for /r . %a in (.) do @if exist %aCVS rd /s /q %aCVS 

 
 
  先用 if exist 判断一下，是因为 for 只是机械的对每个目录进行列举，如果有些目录下面没有CVS也会被执行到。用 if exist 判断一下比较安全。 

  这种删除命令威力太大，请小心使用。最好是在真正执行以上的删除命令前，将 rd /s /q 换成 @echo 先列出要删出的目录，确认无误后再换回rd /s /q： 

 
  程序代码: 
for /r . %a in (.) do @if exist %aCVS @echo %aCVS 

 
 
 
  可能目录中会多出一层 `.`，比如 c:proj elease.CVS ，但不会影响命令的执行效果。 

  2. 将某一文件内容或命令执行结果作为循环范围： 

  假如你有一个文件 todel.txt，里面是所有要删除的文件列表，现在你想将里面列出的每个文件都删掉。假设这个文件是每个文件名占一行，象这样： 

 
  程序代码: 
c: empa1.txt 
c: empa2.txt 
c: empsubdir3.txt 
c: empsubdir4.txt 

 
 
  那么可以用FOR来完成： 

 
  程序代码: 
for /f %a in (todel.txt) do del %a 

 
 
 
  这个命令还可以更强大。比如你的 todel.txt 并不是象上面例子那么干净，而是由DIR直接生成，有一些没用的信息，比如这样： 

 
  程序代码: 
Volume in drive D is DATA 
Volume Serial Number is C47C-9908 

  Directory of D: mp 

  09/26/2001 12:50 PM 18,426 alg0925.txt 
12/02/2001 04:29 AM 795 bsample.txt 
04/11/2002 04:18 AM 2,043 invitation.txt 
4 File(s) 25,651 bytes 
0 Dir(s) 4,060,700,672 bytes free 

 
 
  for 仍然可以解出其中的文件名并进行操作： 

 
  程序代码: 
for /f `skip=5 tokens=5` %a in (todel.txt) do @if exist %a DEL %a 

 
 
  当然，上面这个命令是在进行删除，如果你只是想看看哪些文件将被操作，把DEL换成echo: 

 
  程序代码: 
for /f `skip=5 tokens=5` %a in (todel.txt) do @if exist %a echo %a 

 
 
 
  你将看到： 

 
  程序代码: 
alg0925.txt 
bsample.txt 
invitation.txt 

 
 
  skip=5表示跳过前5行（就是DIR输出的头部信息），tokens=5表示将每行的第5列作为循环值放入%a，正好是文件名。在这里我加了一个文件存在判断，是因为最后一行的`free`刚好也是第5列，目前还想不出好的办法来滤掉最后两行，所以检查一下可保万无一失。 

  3. 可以用 /f 参数将某一命令执行结果作为循环范围 

  非常有用的功能。比如，我们想知道目前的环境变量有哪些名字（我们只要名字，不要值）。可是SET命令的输出是“名字=值”的格式，现在可以用FOR来只取得名字部分： 

 
  程序代码: 
FOR /F `delims==` %i IN (`set`) DO @echo %i 

 
 
  将看到： 

 
  程序代码: 
ALLUSERSPROFILE 
APPDATA 
CLASSPATH 
CommonProgramFiles 
COMPUTERNAME 
ComSpec 
dircmd 
HOMEDRIVE 
...... 

 
 
  这里是将set命令执行的结果拿来作为循环范围。delims==表示用=作为分隔符，由于FOR /F默认是用每行第一个TOKEN，所以可以分离出变量名。如果是想仅列出值： 

 
  程序代码: 
FOR /F `delims== tokens=2` %i IN (`set`) DO @echo %i 

 
 
  tokens=2和前例相同，表示将第二列（由=作为分隔符）作为循环值。 

  再来个更有用的例子： 

  我们知道 date /t （/t表示不要询问用户输入）的输出是象这样的： 

 
  程序代码: 
Sat 07/13/2002 

 
 
 
  现在我想分离出日期部分，也就是13： 

 
  程序代码: 
for /f `tokens=3 delims=/ ` %a in (`date /t`) do @echo %a 

 
 
  实际上把 tokens后面换成1,2,3或4，你将分别得到Sat, 07, 13和2002。注意delims=/后面还有个空格，表示/和空格都是分隔符。由于这个空格delims必须是/f选项的最后一项。 

  再灵活一点，象本文开头提到的，将日期用2002-07-13的格式输出： 

 
  程序代码: 
for /f `tokens=2,3,4 delims=/ ` %a in (`date /t`) do @echo %c-%a-%b 

 
 
 
  当tokens后跟多个值时，将分别映射到%a, %b, %c等。实际上跟你指定的变量有关，如果你指定的是 %i, 它们就会用%i, %j, %k等。 

  灵活应用这一点，几乎没有做不了的事。 

  4. 可以用 %~ 操作符将文件名分离成文件名、扩展名、盘符等独立部分 

  这个比较简单，就是说将循环变量的值自动分离成只要文件名，只要扩展名，或只要盘符等等。 

  例：要将 c:mp3下所有mp3的歌名列出，如果用一般的 dir /b/s 或 for /r ，将会是这样： 

 
  程序代码: 
g:mp3Archived5-18-01-A游鸿明-下沙游鸿明-01 下沙.mp3 
g:mp3Archived5-18-01-A游鸿明-下沙游鸿明-02 21个人.mp3 
...... 
g:mp3Archived5-18-01-A王菲-寓言王菲-阿修罗.mp3 
g:mp3Archived5-18-01-A王菲-寓言王菲-彼岸花.mp3 
g:mp3Archived5-18-01-A王菲-寓言王菲-不爱我的我不爱.mp3 
...... 

 
 
  如果我只要歌名（不要路径和`.mp3`）： 

 
  程序代码: 
游鸿明-01 下沙 
游鸿明-02 21个人 
...... 
王菲-阿修罗 
王菲-彼岸花 
王菲-不爱我的我不爱 
...... 

 
 
  那么可以用FOR命令： 

 
  程序代码: 
for /r g:mp3 %a in (*.mp3) do @echo %~na 

 
 
 
  凡是 %~ 开头的操作符，都是文件名的分离操作。具体请看 for /? 帮助。 

  本文举的例子有些可能没有实际用处，或可用其它办法完成。仅用于体现FOR可以不借助其它工具，仅用DOS命令组合，就可完成相当灵活的任务。 

  具体请看 for /? 帮助 
